# OAuth2
Reference : https://oauth.com/playground/
OAuth2 is a standard security that make a application can access others apps by using token without sharing the credential.

### 1. Authorization flows.
Condition: we had the authorization server.
Whe you registry your application with authorization server, they will provide for you the `client_id` and `redirect_url`, `scope` which will be explain after.
#### Step 1. Build the Authorization URL and redirect user to authorization server
Anyway, you application need build a Authorization URL to communicate with Authorization server.

Example: 
```url
https://authorization-server.com/authorize?
   response_type=code
   &client_id=wiu9zWBBRgimN5XVC1_edW_4
   &redirect_uri=https://oauth.com/playground/authorization-code.html
   &scope=photo+offline_access
   &state=v5hCyrCdsndv9KZV
```
- client_id, redirect_uri and scope is provided by authentication server side.
- state is your random string which is use in authentication server.
You should store your state in somewhere - cookie, session or some other way.

Your application call this url then login form appear for inputing your username and password
#### Step 2. After the user redirect back to client, verify the state matches.
The user was redirected to the client (which request to authorization server)
`?state=v5hCyrCdsndv9KZV&code=lkblOoNANqazf1jX9Lbc6D2zjNJFMPZKOMelKU9DNV_annF5`
You need to verify the `state` parameter that matches the generated state in step 1 so that protect against CSRF attacks
In this example the response tate = `v5hCyrCdsndv9KZV` equals stored state.
If match we go to step 3 else start over.
#### Step 3. Exchange the Authorization Code.
Now you are ready to exchange the authorization code for an access token.
Client build and call the url:
```url
POST https://authorization-server.com/token

grant_type=authorization_code
&client_id=wiu9zWBBRgimN5XVC1_edW_4
&client_secret=e7bp_h8D_VOTc6jIJafkzUO11sGUrFy1_7LZnO_w9dEUdyfc
&redirect_uri=https://oauth.com/playground/authorization-code.html
&code=lkblOoNANqazf1jX9Lbc6D2zjNJFMPZKOMelKU9DNV_annF5
```
- `clien_secret` that is provided by authentication server when you registry your application to use OAuth2.
- `code`: From step 2.
Because we already sign in from step 1 to recived the code - so we don't need the do that by username and password.

The response from above request.
```json
{
"token_type": "Bearer",
"expires_in": 86400,
"access_token": "o6c5yhC9AoUhYq9xGnU_lRovlXhPMF_tU1xa8zvPhilCJAqdbuuGlCyHGK5dIVAMbVM23UmD",
"scope": "photo offline_access",
"refresh_token": "oVHGnV3vBtTh-hou1QAGWQcN"
}
```
- `access_token`: token is used for access APIs on behalf of the user
Now you have the access token to access other application on behalf of the user
- `refresh_token`: token to call refresh token to get the new access_token when expired.

### 2. PKCE flows

#### Step 1: Create a secret code verifier and code challenge
Before do the authorization, we generate the code verifier and code challenge 
- `Code verifier` is a cryptographically random string using A-Z, a-z, 0-9 and punctuation characters like -._~ (hyphen, period, underscore, and tilde) bw 43-128 characters long.
- `Code challenge` use code verifier to create code challenge. That is  base64url(sha256(code_verifier)), otherwise, the same
verifier string is used as the challenge.

Don't forget to store `code verify` in somewhere.

#### Step 2: Build the Authorization URL
```
https://authorization-server.com/authorize?
  response_type=code
  &client_id=IZ44NoLfi3kzN0xubn77cCyr
  &redirect_uri=https://oauth.com/playground/authorization-code-with-pkce.html
  &scope=photo+offline_access
  &state=1uK58ZXs4CQaxUjx
  &code_challenge=nC0DWDvV4sYhILajNCC8diLJ_F_ZuhvV-_aobV0hjCU
  &code_challenge_method=S256
```

- state : generated by your.

#### Step 3: After the user redirect back to client, verify the state matches.
```
?state=1uK58ZXs4CQaxUjx&code=7tFd_VPUH544j7YgsgK2RdlX2QMy6Q733l1UyFvKUeolS2u5
```

#### Step 3. Exchange the Authorization Code
```
POST https://authorization-server.com/token

grant_type=authorization_code
&client_id=IZ44NoLfi3kzN0xubn77cCyr
&client_secret=1KC66EQQyHNU7OwK6m8iyaO1dqWtLN8s1oUFquBX2vmzSRJM
&redirect_uri=https://oauth.com/playground/authorization-code-with-pkce.html
&code=7tFd_VPUH544j7YgsgK2RdlX2QMy6Q733l1UyFvKUeolS2u5
&code_verifier=o8gVvXUrTsObm318iawmFvg4CUFO1OKAdGSMjtoSdSDKXvbI
```
- code_verifier : will be send to Authorization server. Authorization Server will check the verifier matches the challenge code
that was used in the authorization request.
This ensures that a malicious party that intercepted the authorization code will not be able to use it.

The response from token endpoint.
```json
{
  "token_type": "Bearer",
  "expires_in": 86400,
  "access_token": "Mf-PQIJKYQ1gnxPBOpLmSRpt6vAjXxCvtl9lBAhsBbexzYnuYQPZ3Dw6Jnelyz6VjS2s8RcE",
  "scope": "photo offline_access",
  "refresh_token": "QUBhZeEhXN7G7YMie1rlsar1"
}
```

- `access_token`: token is used for access APIs on behalf of the user
  Now you have the access token to access other application on behalf of the user
- `refresh_token`: token to call refresh token to get the new access_token when expired.

### 3. Implicit follow.

#### Step 1: Build the Authorization URL
```
https://authorization-server.com/authorize?
  response_type=token
  &client_id=IZ44NoLfi3kzN0xubn77cCyr
  &redirect_uri=https://oauth.com/playground/implicit.html
  &scope=photo
  &state=vw7pzq-QfDlOgrp5
```
- state : generated by you which will be use in the next step.

#### Step 2: Verify the state parameter
The response from Authorization server.
```
#access_token=6_RmZGn9ifRX5KduRMhIVT2oVJQ0QAdSPojm5MZz42GVLvYaFWwnAx7IgojlK4WDoqrN-9Qb
&token_type=Bearer&expires_in=86400
&scope=photos&state=vw7pzq-QfDlOgrp5
```
- Verify the state value with stored state (protect CSRF attacks)

This doesn't stop a malicious actor from injecting an access token into your client. No solution in OAuth for protecting the Implicit folow.

#### Step 3: Extract  the access token from response of step 2.

access_token 6_RmZGn9ifRX5KduRMhIVT2oVJQ0QAdSPojm5MZz42GVLvYaFWwnAx7IgojlK4WDoqrN-9Qb

token_type	Bearer

expires_in	86400

scope	photos

### 4. Device Code flow.
#### Step 1: Request a device code
You need to request device code, this is done with a simple POST request to `device code endpoint`.
```
POST https://example.okta.com/device     //this is device code endpoint.

client_id=https://www.oauth.com/playground/  //your webside
```
#### Step 2: Tell the User to Enter the Code.
After step 1 - the response from the server includes the device code, a code to display to the user and the URL the user should visit to enter the code.

```json
{
  "device_code": "NGU5OWFiNjQ5YmQwNGY3YTdmZTEyNzQ3YzQ1YSA",  //device code
  "user_code": "BDWD-HQPK",                                  //code display for user
  "verification_uri": "https://example.okta.com/device",    //user should to this link to input the user code from user_code field
  "interval": 5,
  "expires_in": 1800
}
```
If you would like to try with a real device code. Should use https://developers.google.com/identity/protocols/oauth2/limited-input-device

#### Step 3: Poll the Token Endpoint
While you wait for user to visit the URL, sign in the account and approve the request, you need to poll the token endpoint
with the device code until an access token or error is returned.

```
POST https://example.okta.com/token

grant_type=urn:ietf:params:oauth:grant-type:device_code
&client_id=https://www.oauth.com/playground/
&device_code=NGU5OWFiNjQ5YmQwNGY3YTdmZTEyNzQ3YzQ1YSA
```

Before the user has finished signing in and approving the request, the authorization will return a status indicating the authorization is still pending.
HTTP/1.1 400 Bad Request
```json
{
 "error": "authorization_pending"
}
```
In the case this error happen - you can re-poll the request. when the user approves the request, the token endpoint will with the access token.

```json
HTTP/1.1 200 OK

{
  "token_type": "Bearer",
  "access_token": "RsT5OjbzRn430zqMLgV3Ia",
  "expires_in": 3600,
  "refresh_token": "b7a3fac6b10e13bb3a276c2aab35e97298a060e0ede5b43ed1f720a8"
}
```

### 5. OIDC (Open ID connect)
This is protocol that sit on top of OAuth2 framework. OIDC provides authentication by introducing a new ID token which contains logged-in user 
information.

Different with OAuth2 that just provide access token containing scopes only, there are no user information.

`So` OIDC bring standards around sharing identity detail (user information - that is not the sensitive personal information) among the 
application.

Just need to remember - the most processes are same exepted for we have one more field ID Token when use OIDC.
![ODIC_defination.png](..%2Fimages%2FODIC_defination.png)
#### Step 1: Build the Authorization URL
OpenID connect support many same flows as OAuth 2.0. End of OpenID connect process, the client ends up with ID token which contains signed in user 
information. The token is encoded and signed and client can parse it directly.

Same OAuth2.0 we also generate the `state`, don't forget store it.
But in this, we need to generate the `nonce` parameter as well.
```
https://authorization-server.com/authorize?
  response_type=code
  &client_id=vmc9N9LVYQG4y3tH0yKKuHC6
  &redirect_uri=https://oauth.com/playground/oidc.html
  &scope=openid+profile+email+photos
  &state=-S9Mb1qMD2GV-lc9
  &nonce=n183hH4KQPDlAetw
```

#### Step 2: Verify the state parameter
The response from request in `step 1`:
```
?state=-S9Mb1qMD2GV-lc9&code=O0aGWjSFut04BRl-FVy5XgrjF4rX5ssGPr5K2dQLG0g1wIHa
```
Compare response state with your state. if it's matched then continue.

#### Step 3: Exchange the Authorization Code.
Now we exchange authorization code for an access token
Call to this POST endpoint.
```
POST https://authorization-server.com/token

grant_type=authorization_code
&client_id=vmc9N9LVYQG4y3tH0yKKuHC6
&client_secret=chrmHwxJkQags0CcOJq4yTrbeViroNUBqUGFqAmt_ccjB3st
&redirect_uri=https://oauth.com/playground/oidc.html
&code=O0aGWjSFut04BRl-FVy5XgrjF4rX5ssGPr5K2dQLG0g1wIHa
```

Response
```
{
  "token_type": "Bearer",
  "expires_in": 86400,
  "access_token": "YYuzHq8qTfVzK1nFgaY5QtIsw9CiG7MIi2Yt8Ypzfjd8fpu4TWWVOuGIm6l93YT_spF4jHlO",
  "scope": "openid profile email photo",
  "id_token": "eyJraWQiOiJzMTZ0cVNtODhwREo4VGZCXzdrSEtQUkFQRjg1d1VEVGxteW85SUxUZTdzIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJ0ZXN0eS11bmljb3JuQGV4YW1wbGUuY29tIiwibmFtZSI6IlRlc3R5IFVuaWNvcm4iLCJlbWFpbCI6InRlc3R5LXVuaWNvcm5AZXhhbXBsZS5jb20iLCJpc3MiOiJodHRwczovL3BrLWRlbW8ub2t0YS5jb20vb2F1dGgyL2RlZmF1bHQiLCJhdWQiOiJ2bWM5TjlMVllRRzR5M3RIMHlLS3VIQzYiLCJpYXQiOjE3MDk3NDExMDQsImV4cCI6MTcxMjMzMzEwNCwiYW1yIjpbInB3ZCJdfQ.ZoPvZPaomdOnnz2GFRGbgaW7PPWIMFDqSBp0gbN4An4a9F-Bc-4_T9EBGV8aGetyjZYAON0gjNV0p0NGFiwettePWKuxBzusuGCEd9iXWWUO9-WTF5e2AGr3_jkg34dbxfiFXy3KgH7m0czm809cMaiZ_ofLYgJHVD8lqMQoWifhoNhpjPqa19Svc3nCHzSYHUgTXQWvA56NmQvyVPh_OM7GMpc6zHopmihJqt3eREof8N-bOd7FL39jeam2-k1TFSDogyJE513aC0OssRADr_TWvtL8xoaPkXM_7bXYs9_7erXmzF9la0hvmOuasieetpLhOvFeoiOJWCU9xhxj4Q"
}
```
- access_token: Your application use access_token to access other application on behalf of user.
- id_token: The logged-in user information was encoded and signed, client can parse it to get user information - this is JWT token. 


---------------------------
# Other than
## Refresh work follow.
![refresh_token_work_follow.png](..%2Fimages%2Frefresh_token_work_follow.png)
## Resource validation work follow in OAuth2
#### Solution 1: Resource server token validation using directly API call
![authorization_work_follow_1.png](..%2Fimages%2Fauthorization_work_follow_1.png)
#### Solution 2: Resource server token validation using DB
![authorization_work_follow_2.png](..%2Fimages%2Fauthorization_work_follow_2.png)
#### Solution 3: (Recommended)
Resource Server connect to Authorization Server, maybe during start up of web application so can get the public
certificate from my authorization server. So using the same public certificate, when apllication send the access token to resource server that can 
be validated by using public key, that is similarly with the help of `digital signatures` which is in JWT token.

![authorization_work_follow_3.png](..%2Fimages%2Fauthorization_work_follow_3.png)

## Grant type in OAuth2.
- Authorization code grant type
- Client Credentials grant type
- Refresh token grant type : when access token was expired
- Implicit token grant type